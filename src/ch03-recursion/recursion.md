# Recursion Problems

This page lists recursion problems from beginner to advanced. You can
add this file to your main documentation and link to it as **Recursion
Problems**.

## üìö Problem List

### 1. Warm-up (Single Branch)

-   **sumDigits(n)** -- Sum of digits recursively
-   **factorial(n)** -- Classic factorial
-   **reverse(s)** -- Reverse string

### 2. Arrays & Decisions

-   **palindrome(s)** -- Check if string is palindrome
-   **firstIndex(arr, x)** -- Find first occurrence of x
-   **fast power** -- Calculate x‚Åø with divide & conquer

### 3. Combinatorics

-   **subsets(nums)** -- Generate all subsets (power set)

### 4. Permutations

-   **permute(nums)** -- Generate all permutations

### 5. String / DFS Backtracking

-   **phone keypad combinations**
-   **valid parentheses generation**

### 6. Grid / Path Problems

-   **unique paths (no obstacles ‚Üí with obstacles + memoization)**

### 7. Classic Backtracking

-   **N-Queens**

### 8. DP with Recursion + Memoization

-   **coin change (min)** -- Fewest coins to make amount
-   **0/1 Knapsack**
-   **word break**

### 9. Harder Recursion / DP

-   **edit distance** -- Levenshtein distance
-   **palindrome partitioning**
-   **generate unique BSTs**

------------------------------------------------------------------------

## How to Think Recursively

1.  Define **base case** -- smallest input that returns directly.
2.  Break down into a **smaller subproblem**.
3.  Combine results from recursive calls.
4.  Add **memoization** for overlapping subproblems.
